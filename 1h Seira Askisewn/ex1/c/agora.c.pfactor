#include <stdio.h>
#include <stdlib.h>

typedef struct Node node;
void insertOrUpdate(node **head, int prime, int node,int i);
void primeFactor(node **head, long long int in, int i);
void printList(node *n);
void insertAfter(node **head, int prime, int pot, int i);
void deleteNode(node **head, int prime, int pot);
long long int power(long long int a, long long int b);

typedef struct Node {
    int prime;
    int pot;
    int num;
    int i;
    int flag;
    node *next;
}node;

node *pList = NULL;
int main (int argc, char **argv){

    if (argc < 2) {
        printf("Usage: ./agora [input.file]\n");
        exit(1);
    }

    FILE *file = fopen(argv[1],"r");

    int N;
    if(fscanf(file, "%d", &N)==0){
        printf("Failed to read\n");
        fclose(file);
        exit(1);
    }

    long long int *villages = malloc(N*sizeof(long long int));
    int i = 0;

    /*
     * Read input file
     * and store
     * to array
     * Also store maximum value of array
     * and maximum prime value of array if exists
     */

    node *head = NULL;
    while((fscanf(file,"%lld", &villages[i])) == 1){
        primeFactor(&head,villages[i],i);
        i++;
    }

    node *temp = head;

    long long int lcm = 1, other = 0;
    int ans = 0;
    while(temp!=NULL){
        lcm = lcm * power(temp->prime,temp->pot);
        temp = temp->next;
    }

    if (pList!=NULL) {
        other = lcm / pList->prime;
        ans = pList->i;
        lcm = (lcm < other) ? lcm : other;
    }
    printf("%lld %d\n", lcm, ans);
    free(villages);
    fclose(file);

    return 0;
}

void insertOrUpdate(node **head, int prime, int pot,int i){

    node *temp = *head, *prev = NULL;

    if(*head == NULL){
        node *new = (node *)malloc(sizeof(node));
        new->prime = prime;
        new->pot = pot;
        new->num = 1;
        new->i = i+1;
        insertAfter(&pList,new->prime,new->pot,i+1);
        new->next = NULL;
        *head = new;
        return ;
    }

    while(temp!=NULL){
        if(temp->prime == prime) {
            deleteNode(&pList,temp->prime,temp->pot);
            if(pot > temp->pot){
                temp->pot = pot;
                temp->num = 1;
                temp->i = i;
            }
            else if(temp->pot == pot) {
                temp->num++;
                temp->i = i;
            }
            return ;
        }
        prev = temp;
        temp = temp->next;
    }

    node *new = (node *)malloc(sizeof(node));
    new->prime = prime;
    new->pot = pot;
    new->num = 1;
    new->i = i+1;
    insertAfter(&pList,new->prime,new->pot,i+1);
    new->next = NULL;

    prev->next = new;

    return ;
}

void primeFactor(node **head, long long int in, int i){

    int counter = 0;
    int div = 2;

    if(in != 1){
        while(in!=0){
            if(in % div != 0) {
                if(counter!=0) insertOrUpdate(head,div,counter,i);
                div++;
                counter = 0;
            }
            else {
                in = in / div;
                counter++;
                if (in==1){
                    insertOrUpdate(head,div,counter,i);
                    break;
                }
            }
        }
    }
}

void printList(node *n){
    while(n != NULL){
        printf("prime = %d, pot = %d, num = %d village = %d\n", n->prime, n->pot,n->num, n->i);
        n = n->next;
    }
}

long long int power(long long int a, long long int b){
    long long int ans = 1;
    for(int i = 0 ; i < b; i++){
        ans = a * ans;
    }

    return ans;
}

void insertAfter(node **head, int prime, int pot, int i){
    node *new = (node *)malloc(sizeof(node));

    new->prime = prime;
    new->pot = pot;
    new->num = 1;
    new->i = i;

    if(*head == NULL){
        *head = new;
        new->next = NULL;
        return ;
    }

    node *temp = *head;
    node *prev = NULL;

    while(temp!=NULL){
        if(new->prime > temp->prime) {
            if(prev==NULL) {
                new->next = temp;
                *head = new;
                return;
            }
            else {
                new->next = temp;
                prev->next = new;
                return ;
            }
        }
        prev = temp;
        temp = temp->next;
    }

    prev->next = new;
    new->next = NULL;

    return ;
}

void deleteNode(node **head, int prime, int pot){
    node *temp = *head, *prev = NULL;

    if(temp!=NULL && (temp->prime == prime && temp->pot == pot)){
        *head = temp->next;
        free(temp);
        return ;
    }

    while(temp != NULL){
        if(temp->prime == prime && temp->pot == pot) break;
        prev = temp;
        temp = temp->next;
    }

    if (temp == NULL) return ;

    prev->next = temp->next;

    free(temp);

    return ;
}
